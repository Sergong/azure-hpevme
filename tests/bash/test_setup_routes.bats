#!/usr/bin/env bats
# Unit tests for setup-nested-vm-routes.sh
# Test Case 3: Verify that the setup-nested-vm-routes.sh script correctly adds persistent routes for nested VM IP ranges on the KVM hosts

setup() {
  # Load the script for testing
  export SCRIPT_DIR="$(cd "$(dirname "$BATS_TEST_FILENAME")/../.." && pwd)"
  export TEST_ROUTE_FILE="/tmp/test-nested-vm-routes-${BATS_TEST_NUMBER}.conf"
  export MOCK_MGMT_IP="10.0.1.10"
  
  # Create mock functions
  mock_ip_addr_show() {
    echo "2: mgmt: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000"
    echo "    link/ether 00:15:5d:00:00:01 brd ff:ff:ff:ff:ff:ff"
    echo "    inet ${MOCK_MGMT_IP}/24 brd 10.0.1.255 scope global mgmt"
    echo "       valid_lft forever preferred_lft forever"
  }
  
  mock_ip_route_show_empty() {
    # Return empty to simulate no existing route
    return 0
  }
  
  mock_ip_route_show_exists() {
    # Simulate route already exists
    echo "10.0.1.48/28 via 10.0.1.11 dev mgmt"
  }
}

teardown() {
  # Clean up test files
  rm -f "${TEST_ROUTE_FILE}"
}

@test "script extracts host IP from mgmt bridge" {
  # Mock the ip command
  ip() {
    if [[ "$2" == "addr" && "$3" == "show" && "$4" == "mgmt" ]]; then
      mock_ip_addr_show
    fi
  }
  export -f ip
  
  # Extract IP using the same logic as the script
  HOST_IP=$(ip -4 addr show mgmt | grep -o 'inet [0-9.]\+' | awk '{print $2}' | head -1)
  
  [ "$HOST_IP" = "10.0.1.10" ]
}

@test "script parses route entries correctly" {
  ROUTE_ENTRY="10.0.1.16/28:10.0.1.10"
  
  # Extract range and nexthop using parameter expansion (same as script)
  RANGE="${ROUTE_ENTRY%%:*}"
  NEXTHOP="${ROUTE_ENTRY##*:}"
  
  [ "$RANGE" = "10.0.1.16/28" ]
  [ "$NEXTHOP" = "10.0.1.10" ]
}

@test "script skips routes for own IP range" {
  HOST_IP="10.0.1.10"
  NEXTHOP="10.0.1.10"
  
  # Script should skip if NEXTHOP equals HOST_IP
  if [ "$NEXTHOP" == "$HOST_IP" ]; then
    skip_route=true
  else
    skip_route=false
  fi
  
  [ "$skip_route" = "true" ]
}

@test "script adds routes for other hosts" {
  HOST_IP="10.0.1.10"
  NEXTHOP="10.0.1.11"
  
  # Script should not skip if NEXTHOP differs from HOST_IP
  if [ "$NEXTHOP" == "$HOST_IP" ]; then
    skip_route=true
  else
    skip_route=false
  fi
  
  [ "$skip_route" = "false" ]
}

@test "script checks for existing routes before adding" {
  RANGE="10.0.1.48/28"
  NEXTHOP="10.0.1.11"
  
  # Mock ip route show to return existing route
  ip() {
    if [[ "$1" == "route" && "$2" == "show" ]]; then
      echo "10.0.1.48/28 via 10.0.1.11 dev mgmt"
    fi
  }
  export -f ip
  
  # Check if route exists (same logic as script)
  if ip route show "$RANGE" | grep -q "$NEXTHOP"; then
    route_exists=true
  else
    route_exists=false
  fi
  
  [ "$route_exists" = "true" ]
}

@test "script detects when route does not exist" {
  RANGE="10.0.1.48/28"
  NEXTHOP="10.0.1.11"
  
  # Mock ip route show to return empty
  ip() {
    if [[ "$1" == "route" && "$2" == "show" ]]; then
      return 0
    fi
  }
  export -f ip
  
  # Check if route exists
  if ip route show "$RANGE" | grep -q "$NEXTHOP"; then
    route_exists=true
  else
    route_exists=false
  fi
  
  [ "$route_exists" = "false" ]
}

@test "script creates persistent route configuration file" {
  # Simulate creating the route file
  cat > "${TEST_ROUTE_FILE}" <<EOF
# Nested VM routes for cross-host communication
# Generated by setup-nested-vm-routes.sh

EOF
  
  [ -f "${TEST_ROUTE_FILE}" ]
  grep -q "Nested VM routes" "${TEST_ROUTE_FILE}"
}

@test "script writes correct systemd network format for routes" {
  HOST_IP="10.0.1.10"
  RANGE="10.0.1.48/28"
  NEXTHOP="10.0.1.11"
  
  # Skip own routes
  if [ "$NEXTHOP" != "$HOST_IP" ]; then
    cat >> "${TEST_ROUTE_FILE}" <<EOF
[Route]
Gateway=$NEXTHOP
Destination=$RANGE

EOF
  fi
  
  [ -f "${TEST_ROUTE_FILE}" ]
  grep -q "\[Route\]" "${TEST_ROUTE_FILE}"
  grep -q "Gateway=10.0.1.11" "${TEST_ROUTE_FILE}"
  grep -q "Destination=10.0.1.48/28" "${TEST_ROUTE_FILE}"
}

@test "script handles multiple route entries" {
  HOST_IP="10.0.1.10"
  ROUTES=(
    "10.0.1.16/28:10.0.1.10"
    "10.0.1.48/28:10.0.1.11"
    "10.0.1.80/28:10.0.1.12"
  )
  
  route_count=0
  for route_entry in "${ROUTES[@]}"; do
    RANGE="${route_entry%%:*}"
    NEXTHOP="${route_entry##*:}"
    
    if [ "$NEXTHOP" != "$HOST_IP" ]; then
      ((route_count++))
    fi
  done
  
  # Should process 2 routes (skip own range)
  [ "$route_count" -eq 2 ]
}

@test "script validates CIDR notation format" {
  # Valid CIDR formats
  VALID_RANGES=(
    "10.0.1.16/28"
    "10.0.1.48/28"
    "192.168.0.0/24"
  )
  
  for range in "${VALID_RANGES[@]}"; do
    # Check if matches IP/CIDR pattern
    if [[ $range =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; then
      valid=true
    else
      valid=false
    fi
    [ "$valid" = "true" ]
  done
}

@test "script validates IP address format" {
  # Valid IP addresses
  VALID_IPS=(
    "10.0.1.10"
    "10.0.1.11"
    "192.168.1.1"
  )
  
  for ip_addr in "${VALID_IPS[@]}"; do
    # Check if matches IP pattern
    if [[ $ip_addr =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
      valid=true
    else
      valid=false
    fi
    [ "$valid" = "true" ]
  done
}

@test "script configuration file path is correct" {
  ROUTE_FILE="/etc/systemd/network/10-nested-vm-routes.conf"
  
  # Verify it matches systemd network directory
  [[ "$ROUTE_FILE" =~ ^/etc/systemd/network/ ]]
}

@test "script uses correct network device for routes" {
  DEVICE="mgmt"
  
  # Verify device name is mgmt
  [ "$DEVICE" = "mgmt" ]
}
